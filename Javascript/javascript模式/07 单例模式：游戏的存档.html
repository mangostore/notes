<html><head><meta charset="utf-8"><title>07 单例模式：游戏的存档-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">

<div class="container clearfix" id="top" style="display: block; width: 1134px;">
    
    <div class="center_con js-center_con l" style="width: 1134px;">
        <div class="article-con">
                            <!-- 买过的阅读 -->
                <div class="map">
                    <a href="/read" target="_blank"><i class="imv2-feather-o"></i></a>
                    <a href="/read/38" target="_blank">JavaScript 设计模式精讲</a>
                    <a href="" target="_blank">
                        <span>
                            / 2-1 07 单例模式：游戏的存档
                        </span>
                    </a>
                </div>

            


            <div class="art-title" style="margin-top: 0px;">
                07 单例模式：游戏的存档
            </div>
            <div class="art-info">
                
                <span>
                    更新时间：2019-07-03 11:57:32
                </span>
            </div>
            <div class="art-top">
                                <img src="https://img1.mukewang.com/5d11dafa0001b75206400359.jpg" alt="">
                                                <div class="famous-word-box">
                    <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                    <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                    <div class="famous-word">既然我已经踏上这条道路，那么，任何东西都不应妨碍我沿着这条路走下去。<p class="author">——康德</p></div>
                </div>
                            </div>
            <div class="art-content js-lookimg">
                <div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">单例模式可能是设计模式里面最简单的模式了，虽然简单，但在我们日常生活和编程中却经常接触到，本节我们一起来学习一下。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><strong>单例模式</strong> （Singleton Pattern）又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;"><strong>注意：</strong> 本文可能用到一些编码技巧比如 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">IIFE</a>（Immediately Invoked Function Expression, 立即调用函数表达式），ES6 的语法 <a href="http://es6.ruanyifeng.com/#docs/let">let/const</a> ，<a href="https://juejin.im/post/5b51e5d3f265da0f4861143c#heading-5">短路运算符</a>，<a href="http://es6.ruanyifeng.com/#docs/proxy">Proxy</a>，<a href="http://es6.ruanyifeng.com/#docs/reflect">Reflect</a> 等，如果还没接触过可以点击链接稍加学习 ~</p>
</blockquote>
</div><div class="cl-preview-section"><h2 id="你曾经遇见过的单例模式" style="font-size: 30px;">1. 你曾经遇见过的单例模式</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">当我们在电脑上玩经营类的游戏，经过一番眼花缭乱的骚操作好不容易走上正轨，夜深了我们去休息，第二天打开电脑，发现要从头玩，立马就把电脑扔窗外了，所以一般希望从前一天的进度接着打，这里就用到了存档。每次玩这游戏的时候，我们都希望拿到同一个存档接着玩，这就是属于单例模式的一个实例。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">编程中也有很多对象我们只需要唯一一个，比如数据库连接、线程池、配置文件缓存、浏览器中的 window/document 等，如果创建多个实例，会带来资源耗费严重，或访问行为不一致等情况。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">类似于数据库连接实例，我们可能频繁使用，但是创建它所需要的开销又比较大，这时只使用一个数据库连接就可以节约很多开销。一些文件的读取场景也类似，如果文件比较大，那么文件读取就是一个比较重的操作。比如这个文件是一个配置文件，那么完全可以将读取到的文件内容缓存一份，每次来读取的时候访问缓存即可，这样也可以达到节约开销的目的。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在类似场景中，这些例子有以下特点：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">每次访问者来访问，返回的都是同一个实例；</li>
<li style="font-size: 20px; line-height: 38px;">如果一开始实例没有创建，那么这个特定类需要自行创建这个实例；</li>
</ol>
</div><div class="cl-preview-section"><h2 id="实例的代码实现" style="font-size: 30px;">2. 实例的代码实现</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">如果你是一个前端er，那么你肯定知道浏览器中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window">window</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document">document</a> 全局变量，这两个对象都是单例，任何时候访问他们都是一样的对象，<code>window</code> 表示包含 DOM 文档的窗口，<code>document</code> 是窗口中载入的 DOM 文档，分别提供了各自相关的方法。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在 ES6 新增语法的 Module 模块特性，通过 <code>import/export</code> 导出模块中的变量是单例的，也就是说，如果在某个地方改变了模块内部变量的值，别的地方再引用的这个值是改变之后的。除此之外，项目中的全局状态管理模式 Vuex、Redux、MobX 等维护的全局状态，vue-router、react-router 等维护的路由实例，在单页应用的单页面中都属于单例的应用（但不属于单例<strong>模式</strong>的应用）。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在 JavaScript 中使用字面量方式创建一个新对象时，实际上没有其他对象与其类似，因为新对象已经是单例了：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> 		<span class="token comment">// false</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么问题来了，如何对构造函数使用 <code>new</code> 操作符创建多个对象时，仅获取同一个单例对象呢。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">对于刚刚打经营游戏的例子，我们可以用 JavaScript 来实现一下：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">ManageGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ManageGame<span class="token punctuation">.</span>_schedule<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 判断是否已经有单例了</span>
        <span class="token keyword">return</span> ManageGame<span class="token punctuation">.</span>_schedule
    <span class="token punctuation">}</span>
    ManageGame<span class="token punctuation">.</span>_schedule <span class="token operator">=</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>

ManageGame<span class="token punctuation">.</span><span class="token function-variable function">getInstance</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ManageGame<span class="token punctuation">.</span>_schedule<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 判断是否已经有单例了</span>
        <span class="token keyword">return</span> ManageGame<span class="token punctuation">.</span>_schedule
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ManageGame<span class="token punctuation">.</span>_schedule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ManageGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> schedule1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ManageGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> schedule2 <span class="token operator">=</span> ManageGame<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>schedule1 <span class="token operator">===</span> schedule2<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">稍微解释一下，这个构造函数在内部维护（或者直接挂载自己身上）一个实例，第一次执行 <code>new</code> 的时候判断这个实例有没有创建过，创建过就直接返回，否则走创建流程。我们可以用 ES6 的 class 语法改造一下：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">class</span> <span class="token class-name">ManageGame</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> _schedule <span class="token operator">=</span> <span class="token keyword">null</span>
    
    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ManageGame<span class="token punctuation">.</span>_schedule<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 判断是否已经有单例了</span>
            <span class="token keyword">return</span> ManageGame<span class="token punctuation">.</span>_schedule
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ManageGame<span class="token punctuation">.</span>_schedule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ManageGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ManageGame<span class="token punctuation">.</span>_schedule<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 判断是否已经有单例了</span>
            <span class="token keyword">return</span> ManageGame<span class="token punctuation">.</span>_schedule
        <span class="token punctuation">}</span>
        ManageGame<span class="token punctuation">.</span>_schedule <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> schedule1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ManageGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> schedule2 <span class="token operator">=</span> ManageGame<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>schedule1 <span class="token operator">===</span> schedule2<span class="token punctuation">)</span>	<span class="token comment">// true</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面方法的缺点在于维护的实例作为静态属性直接暴露，外部可以直接修改。</p>
</div><div class="cl-preview-section"><h2 id="单例模式的通用实现" style="font-size: 30px;">3. 单例模式的通用实现</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">根据上面的例子提炼一下单例模式，游戏可以被认为是一个特定的类（Singleton），而存档是单例（instance），每次访问特定类的时候，都会拿到同一个实例。主要有下面几个概念：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;"><strong>Singleton</strong> ：特定类，这是我们需要访问的类，访问者要拿到的是它的实例；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>instance</strong> ：单例，是特定类的实例，特定类一般会提供 <code>getInstance</code> 方法来获取该单例；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>getInstance</strong> ：获取单例的方法，或者直接由 <code>new</code> 操作符获取；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里有几个实现点要关注一下：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">访问时始终返回的是同一个实例；</li>
<li style="font-size: 20px; line-height: 38px;">自行实例化，无论是一开始加载的时候就创建好，还是在第一次被访问时；</li>
<li style="font-size: 20px; line-height: 38px;">一般还会提供一个 <code>getInstance</code> 方法用来获取它的实例；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">结构大概如下图：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;"><img src="http://img.mukewang.com/5d157f430001f7a905630327.jpg" alt="图片描述" data-original="http://img.mukewang.com/5d157f430001f7a905630327.jpg" class="" style="cursor: pointer;"><br>
下面使用通用的方法来实现一下。</p>
</div><div class="cl-preview-section"><h3 id="iife-方式创建单例模式">3.1 IIFE 方式创建单例模式</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">简单实现中，我们提到了缺点是实例会暴露，那么这里我们首先使用立即调用函数 IIFE 将不希望公开的单例实例 <code>instance</code> 隐藏。</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">当然也可以使用构造函数复写将闭包进行的更彻底，具体代码参看 <a href="https://github.com/SHERlocked93/imooc-frontend-design-pattern/blob/master/06-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/06-06.singleton%20overwrite%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A4%8D%E5%86%99%E6%96%B9%E5%BC%8F.js">Github 仓库</a>，这里就不贴了。</p>
</blockquote>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> Singleton <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _instance <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token comment">// 存储单例</span>
    
    <span class="token keyword">const</span> <span class="token function-variable function">Singleton</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_instance<span class="token punctuation">)</span> <span class="token keyword">return</span> _instance     <span class="token comment">// 判断是否已有单例</span>
        _instance <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                         <span class="token comment">// 初始化操作</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
    
    Singleton<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'Singleton Pattern'</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> Singleton
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> visitor1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor1 <span class="token operator">===</span> visitor2<span class="token punctuation">)</span>	<span class="token comment">// true</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这样一来，虽然仍使用一个变量 <code>_instance</code> 来保存单例，但是由于在闭包的内部，所以外部代码无法直接修改。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在这个基础上，我们可以继续改进，增加 <code>getInstance</code> 静态方法：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">const</span> Singleton <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _instance <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token comment">// 存储单例</span>
    
    <span class="token keyword">const</span> <span class="token function-variable function">Singleton</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_instance<span class="token punctuation">)</span> <span class="token keyword">return</span> _instance     <span class="token comment">// 判断是否已有单例</span>
        _instance <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                         <span class="token comment">// 初始化操作</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
    
    Singleton<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'Singleton Pattern'</span>
    <span class="token punctuation">}</span>
    
    Singleton<span class="token punctuation">.</span><span class="token function-variable function">getInstance</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_instance<span class="token punctuation">)</span> <span class="token keyword">return</span> _instance
        _instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> Singleton
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> visitor1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">// 既可以 new 获取单例</span>
<span class="token keyword">const</span> visitor3 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 也可以 getInstance 获取单例</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor1 <span class="token operator">===</span> visitor2<span class="token punctuation">)</span>	<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor1 <span class="token operator">===</span> visitor3<span class="token punctuation">)</span>	<span class="token comment">// true</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">代价和上例一样是闭包开销，并且因为 IIFE 操作带来了额外的复杂度，让可读性变差。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">IIFE 内部返回的 <code>Singleton</code> 才是我们真正需要的单例的构造函数，外部的 <code>Singleton</code> 把它和一些单例模式的创建逻辑进行了一些封装。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">IIFE 方式除了直接返回一个方法/类实例之外，还可以通过模块模式的方式来进行，就不贴代码了，代码实现在 <a href="https://github.com/SHERlocked93/imooc-frontend-design-pattern/blob/20190625/07-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/07-08.singleton%20%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F%E6%96%B9%E5%BC%8F.js">Github 仓库</a>中，读者可以自己瞅瞅。</p>
</div><div class="cl-preview-section"><h3 id="块级作用域方式创建单例">3.2 块级作用域方式创建单例</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">IIFE 方式本质还是通过函数作用域的方式来隐藏内部作用域的变量，有了 ES6 的 let/const 之后，可以通过 <code>{ }</code> 块级作用域的方式来隐藏内部变量：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">let</span> getInstance

<span class="token punctuation">{</span>
    <span class="token keyword">let</span> _instance <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token comment">// 存储单例</span>
    
    <span class="token keyword">const</span> <span class="token function-variable function">Singleton</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_instance<span class="token punctuation">)</span> <span class="token keyword">return</span> _instance     <span class="token comment">// 判断是否已有单例</span>
        _instance <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                         <span class="token comment">// 初始化操作</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
    
    Singleton<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'Singleton Pattern'</span>
    <span class="token punctuation">}</span>
    
    <span class="token function-variable function">getInstance</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_instance<span class="token punctuation">)</span> <span class="token keyword">return</span> _instance
        _instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> visitor1 <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor2 <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor1 <span class="token operator">===</span> visitor2<span class="token punctuation">)</span>

<span class="token comment">// 输出: true</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">怎么样，是不是对块级作用域的理解更深了呢～</p>
</div><div class="cl-preview-section"><h3 id="单例模式赋能">3.3 单例模式赋能</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">之前的例子中，单例模式的创建逻辑和原先这个类的一些功能逻辑（比如 <code>init</code> 等操作）混杂在一起，根据<strong>单一职责原则</strong>，这个例子我们还可以继续改进一下，将单例模式的创建逻辑和特定类的功能逻辑拆开，这样功能逻辑就可以和正常的类一样。</p>
</div><div class="cl-preview-section"><pre class=" language-javascript"><code class="prism  language-javascript"><span class="token comment">/* 功能类 */</span>
<span class="token keyword">class</span> <span class="token class-name">FuncClass</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> bar
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'Singleton Pattern'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 单例模式的赋能类 */</span>
<span class="token keyword">const</span> Singleton <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _instance <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token comment">// 存储单例</span>
    
    <span class="token keyword">const</span> <span class="token function-variable function">ProxySingleton</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_instance<span class="token punctuation">)</span> <span class="token keyword">return</span> _instance     <span class="token comment">// 判断是否已有单例</span>
        _instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FuncClass</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
    
    ProxySingleton<span class="token punctuation">.</span><span class="token function-variable function">getInstance</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_instance<span class="token punctuation">)</span> <span class="token keyword">return</span> _instance
        _instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> ProxySingleton
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> visitor1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token string">'单例1'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token string">'单例2'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor3 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor1 <span class="token operator">===</span> visitor2<span class="token punctuation">)</span>	<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor1 <span class="token operator">===</span> visitor3<span class="token punctuation">)</span>	<span class="token comment">// true</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这样的单例模式赋能类也可被称为<strong>代理类</strong>，将业务类和单例模式的逻辑解耦，把单例的创建逻辑抽象封装出来，有利于业务类的扩展和维护。代理的概念我们将在后面<strong>代理模式</strong>的章节中更加详细地探讨。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">使用类似的概念，配合 ES6 引入的 <code>Proxy</code> 来拦截默认的 <code>new</code> 方式，我们可以写出更简化的单例模式赋能方法：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">/* Person 类 */</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 单例模式的赋能方法 */</span>
<span class="token keyword">function</span> <span class="token function">Singleton</span><span class="token punctuation">(</span>FuncClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _instance
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>FuncClass<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">construct</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> _instance <span class="token operator">||</span> <span class="token punctuation">(</span>_instance <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>FuncClass<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 使用 new FuncClass(...args) 也可以</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> PersonInstance <span class="token operator">=</span> <span class="token function">Singleton</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span>

<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonInstance</span><span class="token punctuation">(</span><span class="token string">'张小帅'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonInstance</span><span class="token punctuation">(</span><span class="token string">'李小美'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1 <span class="token operator">===</span> person2<span class="token punctuation">)</span>	<span class="token comment">// true</span>
</code></pre>
</div><div class="cl-preview-section"><h2 id="惰性单例、懒汉式-饿汉式" style="font-size: 30px;">4. 惰性单例、懒汉式-饿汉式</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">有时候一个实例化过程比较耗费性能的类，但是却一直用不到，如果一开始就对这个类进行实例化就显得有些浪费，那么这时我们就可以使用<strong>惰性创建</strong>，即延迟创建该类的单例。之前的例子都属于惰性单例，实例的创建都是 <code>new</code> 的时候才进行。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">惰性单例又被成为<strong>懒汉式</strong>，相对应的概念是<strong>饿汉式</strong>：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">懒汉式单例是在使用时才实例化</li>
<li style="font-size: 20px; line-height: 38px;">饿汉式是当程序启动时或单例模式类一加载的时候就被创建。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们可以举一个简单的例子比较一下：</p>
</div><div class="cl-preview-section"><pre class="  language-js"><code class="prism  language-js"><span class="token keyword">class</span> <span class="token class-name">FuncClass</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 饿汉式</span>
<span class="token keyword">const</span> HungrySingleton <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> _instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FuncClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> _instance
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 懒汉式</span>
<span class="token keyword">const</span> LazySingleton <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _instance <span class="token operator">=</span> <span class="token keyword">null</span>
    
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> _instance <span class="token operator">||</span> <span class="token punctuation">(</span>_instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FuncClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> visitor1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> visitor4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor1 <span class="token operator">===</span> visitor2<span class="token punctuation">)</span>	<span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>visitor3 <span class="token operator">===</span> visitor4<span class="token punctuation">)</span>	<span class="token comment">// true</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">可以打上 <code>debugger</code> 在控制台中看一下，饿汉式在 <code>HungrySingleton</code> 这个 IIFE 执行的时候就进入到 <code>FuncClass</code> 的实例化流程了，而懒汉式的 <code>LazySingleton</code> 中 <code>FuncClass</code> 的实例化过程是在第一次 <code>new</code> 的时候才进行的。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">惰性创建在实际开发中使用很普遍，了解一下对以后的开发工作很有帮助。</p>
</div><div class="cl-preview-section"><h2 id="源码中的单例模式" style="font-size: 30px;">5. 源码中的单例模式</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">以 ElementUI 为例，ElementUI 中的全屏 Loading 蒙层调用有两种形式：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">// 1. 指令形式</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Loading<span class="token punctuation">.</span>directive<span class="token punctuation">)</span>
<span class="token comment">// 2. 服务形式</span>
Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$loading <span class="token operator">=</span> service
</code></pre>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">上面的是指令形式注册，使用的方式 <code>&lt;div :v-loading.fullscreen="true"&gt;...&lt;/div&gt;</code>；</li>
<li style="font-size: 20px; line-height: 38px;">下面的是服务形式注册，使用的方式 <code>this.$loading({ fullscreen: true })</code>；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">用服务方式使用全屏 Loading 是单例的，即在前一个全屏 Loading 关闭前再次调用全屏 Loading，并不会创建一个新的 Loading 实例，而是返回现有全屏 Loading 的实例。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面我们可以看看 ElementUI 2.9.2 的<a href="https://github.com/ElemeFE/element/blob/v2.9.2/packages/loading/src/index.js">源码</a>是如何实现的，为了观看方便，省略了部分代码：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> loadingVue <span class="token keyword">from</span> <span class="token string">'./loading.vue'</span>

<span class="token keyword">const</span> LoadingConstructor <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>loadingVue<span class="token punctuation">)</span>

<span class="token keyword">let</span> fullscreenLoading

<span class="token keyword">const</span> <span class="token function-variable function">Loading</span> <span class="token operator">=</span> <span class="token punctuation">(</span>options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>fullscreen <span class="token operator">&amp;&amp;</span> fullscreenLoading<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> fullscreenLoading
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LoadingConstructor</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        data<span class="token punctuation">:</span> options
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>fullscreen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fullscreenLoading <span class="token operator">=</span> instance
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> instance
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Loading
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里的单例是 <code>fullscreenLoading</code>，是存放在闭包中的，如果用户传的 <code>options</code> 的 <code>fullscreen</code> 为 true 且已经创建了单例的情况下则回直接返回之前创建的单例，如果之前没有创建过，则创建单例并赋值给闭包中的 <code>fullscreenLoading</code> 后返回新创建的单例实例。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这是一个典型的单例模式的应用，通过复用之前创建的全屏蒙层单例，不仅减少了实例化过程，而且避免了蒙层叠加蒙层出现的底色变深的情况。</p>
</div><div class="cl-preview-section"><h2 id="单例模式的优缺点" style="font-size: 30px;">6. 单例模式的优缺点</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">单例模式主要解决的问题就是<strong>节约资源，保持访问一致性</strong>。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">简单分析一下它的优点：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；</li>
<li style="font-size: 20px; line-height: 38px;">单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；</li>
<li style="font-size: 20px; line-height: 38px;">只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；</li>
</ol>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">单例模式也是有缺点的</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">单例模式对扩展不友好，一般<strong>不容易扩展</strong>，因为单例模式一般自行实例化，没有接口；</li>
<li style="font-size: 20px; line-height: 38px;"><strong>与单一职责原则冲突</strong>，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；</li>
</ol>
</div><div class="cl-preview-section"><h2 id="单例模式的使用场景" style="font-size: 30px;">7. 单例模式的使用场景</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那我们应该在什么场景下使用单例模式呢：</p>
</div><div class="cl-preview-section"><ol>
<li style="font-size: 20px; line-height: 38px;">当一个类的<strong>实例化过程消耗的资源过多</strong>，可以使用单例模式来避免性能浪费；</li>
<li style="font-size: 20px; line-height: 38px;">当项目中需要一个公共的状态，那么需要使用单例模式来<strong>保证访问一致性</strong>；</li>
</ol>
</div></div>
            </div>
                            <!-- 买过的阅读 -->
                <div class="art-next-prev clearfix">
                                                                        <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/38/article/506">
                                                    <div class="prev l clearfix">
                                <div class="icon l">
                                    <i class="imv2-arrow3_l"></i>
                                </div>
                                <p>
                                    06 设计原则
                                </p>
                            </div>
                        </a>
                                                                                            <!-- 已买且开放 或者可以试读 -->
                            <a href="/read/38/article/482">
                                                    <div class="next r clearfix">
                                <p>
                                    08 工厂模式：去小餐馆下馆子
                                </p>
                                <div class="icon r">
                                    <i class="imv2-arrow3_r"></i>
                                </div>

                            </div>
                        </a>
                                    </div>
                    </div>
        <div class="comments-con js-comments-con" id="coments_con">
        </div>



    </div>
    
    
    

</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>